# Visualization of the Series Dark

## English

### Preface
Unfortunately, the final project documentation had to be postponed due to considerable time pressure. As a result, now, around five months after completion, I can no longer clearly determine which specific files, components, or objects ultimately made it into the finished final product. <br>
To nevertheless provide a comprehensible insight, I document in this README the overall process, the key decisions, and the most important technical steps. Even though individual artifacts are no longer available, this description should make the project transparent. <br>

### Tools Used
For this project, I worked with Python, HTML, JavaScript, Graphviz, Figma, and Drawio. <br>
Within the group, NetworkX was also used. <br>

### Project Task
This project was carried out collaboratively by a group of seven students. <br>
At the beginning of the module, three different topic areas were offered to choose from. After a brief discussion within the group, we decided to participate in the creative track of the Graph Drawing Contest 2025. <br>
The Graph Drawing Contest has been held annually since 1994 as part of the International Symposium on Graph Drawing and Network Visualization. Its goal is to support and observe developments in graph-based visualizations, as well as to encourage new approaches in graph drawing algorithms. Over the years, several contest categories have been established, ranging from classical graph drawing to creative aspects and theme-specific challenges. <br>
In 2025, the creative part of the competition was dedicated to the German series Dark, which features complex timelines, character relationships, and parallel worlds. Based on a provided dataset consisting of two CSV files—nodes and edges—a static visualization on a freely chosen theme was to be created. This visualization needed to illustrate both the temporal and causal relationships within the complex series. Participants were free to omit parts of the dataset. <br>
A special feature of the 2025 contest was that the submissions were displayed in the Norrköping Decision Arena, a 360° visualization environment that offered new design possibilities. The submission had to be a PNG file in panorama format (12288 × 1200 pixels). <br>
In the end, we decided to create a graph depicting the development of the main character Jonas/Adam. <br>

### Positioning of the Nodes
The main challenge consisted of determining how the nodes and edges should be arranged to produce an appealing graph, considering the problem statement. The specified resolution of 12288 × 1200 pixels proved particularly challenging. Naive algorithmic approaches that automatically position nodes and edges were mostly inapplicable and required adjustments. <br>
An initial draft was developed with NetworkX in Python, following an interesting core concept. Events forming the longest loop were evenly arranged horizontally at the center. The remaining dataset was then modeled around these 153 nodes. Unfortunately, the placement of the other nodes was less satisfactory—the edges were confusing, and some nodes overlapped despite the algorithm. <br>
A further graph was developed with Graphviz, using only the nodes in which Jonas appears. Pseudo-edges were created to ensure continued connectivity among nodes. Once again, the longest loop was arranged horizontally. <br>
Since none of the previous layouts were truly satisfactory, we tested another approach. It was important to us to meaningfully utilize the 360° screen for the final presentation. Standard algorithms for node positioning are not well suited for this, as they do not account for edges wrapping from one side of the screen to the other. They also tend to distribute nodes in circular rather than elongated layouts. However, the coordinates of a circular layout can be transformed into a linear layout. To accomplish this, we computed the polar coordinates (radius, angle) of each node relative to the center of the circular layout. The new horizontal position in the rectangular layout was derived from the normalized angle scaled to the required width, and the vertical position from the normalized radius scaled to the required height. <br>
The task then became to generate a suitable circular layout. Using NetworkX functions, we encountered the problem that some nodes formed a long chain that was repelled from the center, preventing the layout from becoming circular enough—or causing incorrect vertical scaling. For this reason, we used the interactive tool Gephi, which allows various algorithm parameters to be adjusted, including the attraction to the center, ensuring a nearly circular layout. Another advantage was the ability to manually reposition or fix nodes. <br>
Since it became clear during the project that it was useful to focus on a subset of nodes, we first loaded only the nodes in which Jonas appears into Gephi and positioned them so that they were evenly distributed. Nevertheless, we wanted to include all nodes and edges, even if displayed only minimally. We therefore fixed the first nodes, added the remaining nodes, and arranged them around them. When we combined this layout with the full designs of the nodes, it became evident that some nodes still overlapped too much, making descriptions unreadable. <br>
Subsequently, several manual adjustments were made to achieve our final layout. In the end, only the coordinate transformation back to the linear layout remained. For use in D3.js, the graph with its final node coordinates was exported as a JSON file. <br>

### Design of the Edges
he dataset for the edges was provided as a CSV file named Dark_GD_Contest_Edges.csv. Each edge has an ID, a source, a target, a type, and a description. In total, there are 628 edges divided into eight types. <br>
To determine how to represent the edges, we first had to study the dataset and understand what the edges mean and how important they are. This was necessary to choose appropriate and intuitive edge designs. <br>
To establish a starting point to build upon, we created a first prototype version of the design. This was created in Python using Graphviz. Graphviz is an open-source software package that allowed us to implement our initial ideas for edge visualization. After some discussion, our first preliminary version of the edge design emerged. <br>
For the next design step, we chose Figma, a collaborative tool for creating design prototypes—exactly what we needed. Since we also had access to the premium version through Freie Universität Berlin, we were able to use Figma for the next stage of our design process. <br>
Although Figma offers export functions for many elements, it does not allow exporting edges. Therefore, we redesigned the edges from scratch using D3.js. <br>

### Design of the Nodes
The node design was fully developed in Figma. This tool quickly proved intuitive and easy to use while providing a solid technical foundation. The designs were iteratively developed in Figma and then integrated into the graph using CSS export. <br>
Once the background and edge colors were finalized, we could determine the final node color scheme and make decisions that improved the overall readability of the graph. Various options were explored before one was selected. <br>
Additionally, we wanted to design node variants that mark potential starting and ending points of the graph’s narrative. The nature of the story made this challenging, so we selected a node that appears early in the chronological narrative. These nodes were clearly marked with a play symbol (start) and a flag (end) and also visually differentiated by color. <br>

### Final Implementation
In the final phase of the project, several challenges had to be overcome. The automatically generated layouts using NetworkX and MatPlotLib produced visuals that lacked clarity. Even with significant effort and multiple approaches, the issue could not be adequately resolved. To still achieve a satisfactory result with these tools, we introduced another one: Drawio. In Drawio, the selected nodes were manually distributed, and corresponding edges were drawn. Minor nodes were not meant to be depicted in detail but merely to outline the paths of the edges. Thus, only nodes relevant to Jonas’s character development were displayed in full detail with descriptions, while less important nodes remained visible but simplified—indicating the existence of events between major nodes. <br>
Drawio provided the coordinates of each node in the overall image, which could then be fed back into NetworkX. This ensured that the final product was organized and clear. In the finished visualization, the primary elements are the nodes relevant to Jonas’s development. Secondary nodes located between these are shown as small dots. Tertiary nodes not used in the main analysis were positioned in the background using NetworkX. Finally, we needed to create a “red thread” that visually distinguishes relevant connections from irrelevant ones. <br>

### Personal Role in the Project
I was primarily involved in the design and implementation of the edges. After completing that work, I also participated in the manual adjustment of nodes using Drawio.

### Project Reflection
A central success factor of our project was the strong cohesion within the team. It is particularly noteworthy that everyone supported each other. When someone temporarily had less capacity, others stepped in and took over tasks. This mutual understanding and flexibility significantly contributed to the stability of the project process. <br>
Task distribution worked well. All team members took responsibility for their respective areas and actively contributed to the project’s success. The combination of commitment, accountability, and collegial collaboration created a very productive working atmosphere. <br>
Although the project was successful overall, there were some aspects that could have been improved in hindsight. One issue was the project documentation. We neglected it during the project and postponed it repeatedly. This led to additional time pressure toward the end, which could have been avoided had we maintained the documentation more consistently throughout the project. Another major challenge was that solutions we were initially satisfied with often turned out later to be inadequate. This repeatedly created unexpected additional workload, which caused significant time pressure toward the end of the project. <br>


---

## German

### Vorwort
Die abschließende Dokumentation des Projekts musste aufgrund von erheblichem Zeitdruck leider zurückgestellt werden. Dadurch ist es mir heute, rund fünf Monate nach Abschluss, nicht mehr möglich eindeutig nachzuvollziehen, welche spezifischen Dateien, Komponenten oder Objekte letztlich in das fertige Endprodukt eingeflossen sind. <br>
Um dennoch einen nachvollziehbaren Einblick zu geben, dokumentiere ich in diesem README den Gesamtprozess, die zentralen Entscheidungen sowie die wichtigsten technischen Schritte. Auch wenn einzelne Artefakte nicht mehr vorliegen, soll diese Darstellung das Projekt transparent machen.

### Verwendete Werkzeuge
Ich habe im Rahmen dieses Projektes mit Python, HTML, JavaScript, Graphviz, Figma und Drawio gearbeitet. <br>
Innerhalb der Gruppe wurde außerdem NetworkX verwendet. <br>

### Projektaufgabe
In diesem Projekt wurde aus einer Gruppe aus sieben Studierenden zusammengearbeitet. <br>
Zu Beginn des Moduls standen drei verschiedene Themenbereiche zur Auswahl, aus denen frei gewählt werden konnte. Nach einer kurzen Rücksprache innerhalb der Gruppe entschieden wir uns für die Teilnahme am kreativen Teil des Graph Drawing Contest 2025. <br>
Der Graph Drawing Contest wird seit 1994 jährlich im Rahmen des “International Symposium on Graph Drawing and Network Visualization” veranstaltet. Ziel des Wettbewerbs ist es, Entwicklungen im Bereich der graphbasierten Visualisierungen zu unterstützen und zu beobachten, sowie neue Ansätze in Graphzeichenalgorithmen anzuregen. Über die Jahre haben sich verschiedene Wettbewerbskategorien etabliert, vom klassischen Graphenzeichnen über kreative Aspekte bis hin zu themenspezifischen Herausforderungen. <br>
Im Jahr 2025 widmete sich der kreative Teil des Wettbewerbs der deutschen Serie “Dark”, welche komplexe Zeitlinien, Charakterbeziehungen und Parallelwelten behandelt. Auf Basis eines vorgegebenen Datensatzes bestehend aus zwei CSV-Dateien, Knoten und Kanten, war eine statische Visualisierung auf Basis eines selbst gewählten Themas zu gestalten. Diese sollte sowohl die zeitlichen als auch die kausalen Zusammenhänge innerhalb der komplexen Serie veranschaulichen. Es war den Teilnehmenden freigestellt, Teile des Datensatzes wegzulassen. <br>
Eine Besonderheit im Jahr 2025 war die Darstellung der Einreichungen in der Norrköping Decision Arena, einer 360°-Visualisierungsumgebung, die neue gestalterische Möglichkeiten bot. Die Einreichung war als PNG-Datei im Panoramaformat (12288 × 1200 Pixel) gefordert. <br>
Wir haben uns am Ende dafür entschieden, einen Graphen zu erstellen, der die Entwicklung vom Hauptchrakter Jonas/Adam darstellen soll.

### Positionierung der Knoten
Die Hauptaufgabe bestand darin, sich zu überlegen, wie die Knoten und Kanten grob angeordnet sein sollten, damit ein ansehnlicher Graph entsteht unter Betrachtung der Problemstellung. Als besonders herausfordernd gestaltete sich die vorgegebene Auflösung von 12288 x 1200 Pixel. Naive algorithmische Ansätze, welche Knoten und Kanten automatisch positionieren, waren deswegen meist nicht anwendbar und erforderten Anpassungen. <br>
Ein erster Entwurf wurde mit NetworkX in Python entwickelt, der ein interessantes Grundkonzept verfolgte. Dabei wurden die Events, welche die längste Schleife bilden, horizontal mittig gleichmäßig angeordnet. Um diese 153 Knoten wurde anschließend der restliche Datensatz modelliert. Leider war die Platzierung der anderen Knoten weniger zufriedenstellend. Die Kanten verliefen unübersichtlich und einige Knoten überlappten trotz des Algorithmus. <br>
Weiterführend dazu wurde ein Graphen mit Graphviz entwickelt, der nur den Teil der Knoten verwendet, in denen Jonas vorkommt. Es wurden Pseudo-Kanten erstellt, um die Knoten weiterhin zu verknüpfen. Horizontal angeordnet wurde hier genauso die längste Schleife. <br>
Da keines der bisherigen Layouts wirklich zufriedenstellend war, wurde ein weiterer Ansatz getestet. Es war uns wichtig, dass wir den 360° Bildschirm für diefinale Darstellung weiterhin sinnvoll nutzten. Normale Algorithmen für das Positionieren von Knoten sind dafür nicht direkt geeignet, da sie nicht berücksichtigen, dass Kanten über den Rand hinaus zur anderen Seite gehen können. Zudem verteilen sie die Knoten eher kreisförmig als länglich. Allerdings kann man die Koordinaten eines kreisförmigen Layouts in ein lineares Layout transformieren. Dazu wurden für jeden Knoten die Polarkoordinaten (Radius, Winkel) relativ zum Mittelpunkt des kreisförmigen Layouts berechnet. Die neue horizontale Position im Rechteck ergibt sich dann aus dem normierten Winkel, skaliert auf die erforderliche Breite und die neue vertikale Position ergibt sich aus dem normierten Radius, skaliert auf die erforderliche Höhe. <br>
Die Aufgabe bestand nun darin ein geeignetes kreisförmiges Layout zu erzeugen, mit den Funktionen von NetworkX gab es das Problem, dass einige Knoten eine lange Kette bildeten, die vom Zentrum abgestoßen wurde und so das Layout nicht kreisförmig genug war, bzw. die Skalierung in der Höhe nicht funktionierte. Aus diesem Grund wurde das interaktive Tool Gephi verwendet, welches ermöglicht, bei den Algorithmen verschiedene Parameter einzustellen, unter anderem auch die Anziehung zum Mittelpunkt, welche sicherstellte, dass ein nahezu kreisförmiges Layout erzeugt wird. Zudem hatte es auch den Vorteil, dass einzelne Knoten manuell verschoben oder auch Knoten fixiert werden können. Da sich im Laufe des Projekts ergab, dass es sinnvoll ist, sich auf eine Teilmenge von Knoten zu fokussieren, wurden zunächst nur die Knoten, in denen Jonas vorkommt, in Gephi geladen und positioniert, damit diese möglichst gleichmäßig verteilt sind. Dennoch fanden wir es wünschenswert alle Knoten und Kanten mit einzubeziehen, auch wenn wir diese nur minimalistisch darstellen. Aus diesem Grund wurden die ersten Knoten fixiert, die restlichen Knoten hinzugefügt und drum herum angeordnet. Als wir dieses Layout mit den vollständigen Designs der Knoten kombinierten, zeigte sich jedoch, dass die Knoten sich an einigen Stellen immer noch zu sehr überlappten, sodass die Beschreibungen nicht lesbar waren. <br>
Nachfolgend wurden noch einige manuelle Anpassungen vorgenommen für unser finales Layout. Zum Schluss mussten nur noch die Koordinaten wieder in das lineare Layout transformiert werden. Für die Verwendung in D3.js wurde der Graph mit den finalen Knoten-Koordinaten in Form einer JSON Datei exportiert. <br>

### Design der Kanten
Der Datensatz zu den Kanten wurde uns als eine csv-Datei namens „Dark_GD_Contest_Edges.csv“ bereitgestellt. Jede Kante hat eine ID, eine Quelle, ein Ziel, einen Typen und eine Beschreibung. Insgesamt gibt es 628 Kanten, die in acht Typen aufgeteilt waren. <br>
Um zu entscheiden, wie wir die Kanten darstellen wollen, mussten wir uns erst in den Datensatz einarbeiten und herausfinden, was die Kanten bedeuten und welche Wichtigkeit sie darstellen. Nur so konnten wir passende und intuitive Designs für die Kanten wählen. <br>
Um einen Ausgangspunkt zu haben, an dem gearbeitet werden kann, haben wir eine erste Prototyp-Version des Designs erstellt. Diese wurde in Python mithilfe von Graphviz erstellt. Graphviz ist ein Open-Source-Programmpaket, welches uns erlaubt hat, unsere ersten Ideen zur Visualisierung der Kanten umzusetzen. Nach etwas Austausch entstand so unsere erste vorläufige Version des Kantendesigns. <br>
Im nächsten Designschritt haben wir uns für Figma entschieden. Figma ist eine kollaborative Software zum Erstellen von Design-Prototypen, also genau das was wir brauchten. Dadurch, dass uns durch die Freie Universität Berlin außerdem die kostenpflichtige Version zur Verfügung gestellt wird, konnten wir damit den nächsten Schritt unseres Designprozesses durchführen. <br>
Figma bietet zwar an vielen Stellen eine Exportfunktion für Elemente an, jedoch nicht für Kanten. Deswegen haben wir die Kanten von Grund auf mit “D3.js” neu designt. <br>

### Design der Knoten
Das Design wurde vollständig in Figma ausgearbeitet. Dieses Werkzeug stellte sich schnell als intuitiv und niedrigschwellig heraus und sorgte auch für eine technisch ansprechende Grundlage. So wurden die Entwürfe stufenweise in Figma weiterentwickelt und anschließend mithilfe von CSS-Export in die Erstellung des Graphen eingebunden. <br>
Nachdem Hintergrundfarbe und auch die Kantenfarben feststanden konnten wir die Farbgebung der Knoten final festlegen und auch in Sachen Lesbarkeit des Gesamtgraphen passende Entscheidungen fällen. So wurden verschiedene Optionen ausgearbeitet und aus diesen eine ausgewählt. Zusätzlich wollten wir noch Knotendesigns erarbeiten, die einen möglichen Start- und Zielpunkt der Betrachtung ermöglichen. Die Natur der Erzählung der Geschichte macht dies natürlich schwer, weshalb ein Knoten gewählt wurde, der in der Chronologie des Erzählstrangs möglichst früh zu verzeichnen ist. Diese sind deutlich markiert mit einem Play-Zeichen (Start) und einer Fahne (Ziel) und heben sich auch farblich vom Rest ab.

### Finale Umsetzung
In der abschließenden Phase des Projekts mussten einige Hürden gemeistert werden. Das Layout des Graphen, das mithilfe von NetworkX und MatPlotLib automatisch generiert wurde, erzeugte wenig übersichtliche Darstellungen. Auch mit einiger Arbeit und verschiedenen Herangehensweisen konnte diese Problematik nicht zufriedenstellend gelöst werden. Um trotzdem ein zufriedenstellendes Ergebnis mithilfe dieser Werkzeuge zu ermöglichen, wurde ein weiteres herangezogen - drawio. In drawio wurden händisch die selektierten Knoten verteilt und entsprechende Kanten gelegt. Kleinere Knoten sollten dabei nicht ausführlich dargestellt werden, sondern nur den Pfad der Kanten abstecken. So werden nur für die Fragestellung relevante Knoten in aller Ausführlichkeit mit Beschreibungen angezeigt, die weniger relevanten Knoten trotzdem sichtbar und die Existenz von Geschehnissen zwischen großen Knoten deutlich. Drawio lieferte die Koordinaten der jeweiligen Knoten auf dem Gesamtnild, die dann wieder in NetworkXeingespeist werden konnten. Somit konnte ein geordnetes und übersichtliches Produkt gewährleistet werden. Im finalen Produkt werden primär also nur Knoten angezeigt, die relevant für die Charakterentwicklung von Jonas sind. Sekundär sind die Knoten, die zwischen eben jenen Knoten liegen, als kleinere Punkte sichtbar. Tertiär wurden mithilfe von NetworkX alle nicht verwendeten Knoten im Hintergrund um den bis dato entstandenen Graphen gelegt. Abschließend musste noch ein “roter Faden” geschaffen werden, der die Verbindungen zwischen den relevanten Knoten von den irrelevanten abhebt. <br>

### Eigene Rolle im Projekt
Ich war primär am Entwurf, Design und der Implementierung der Kanten beteiligt. Nachdem dies fertiggestellt war, habe ich zudem an der manuellen Anpassung der Knoten mit Hilfe von Drawio teilgenommen. <br>

### Reflexion des Projektes
Ein zentraler Erfolgsfaktor unseres Projekts war der starke Zusammenhalt innerhalb des
Teams. Besonders hervorzuheben ist, dass sich alle gegenseitig unterstützt haben. Wenn
jemand kurzfristig weniger Kapazitäten hatte, sind andere eingesprungen und haben
Aufgaben übernommen. Dieses gegenseitige Verständnis und die Flexibilität haben
wesentlich zur Stabilität des Projektverlaufs beigetragen. <br>
Die Aufgabenverteilung funktionierte gut. Alle Teammitglieder übernahmen Verantwortung
für ihre Teilbereiche und trugen aktiv zum Gelingen des Projekts bei. Die Kombination aus
Engagement, Eigenverantwortung und kollegialem Miteinander schuf eine sehr produktive
Arbeitsatmosphäre. <br>
Auch wenn das Projekt insgesamt erfolgreich verlaufen ist, gab es einige Aspekte, die rückblickend verbessert werden könnten. Ein Punkt war die Projektdokumentation. Diese haben wir im Laufe des Projekts eher vernachlässigt und zunehmend nach hinten geschoben. Dadurch entstand gegen Ende ein zusätzlicher Zeitdruck, was vermeidbar gewesen wäre, wenn wir die Dokumentation parallel zum Projektfortschritt konsequenter gepflegt hätten. Ein großes Problem stellte außerdem dar, dass Lösungen, mit denen wir zunächst zufrieden waren, sich oftmals später als unzureichend herausstellten. So mussten kam mehrmals ein unerwarteter Mehraufwand auf, der uns gegen Ende des Projektes vor große zeitliche Schwierigkeiten stellte. <br>
